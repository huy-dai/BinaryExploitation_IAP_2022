Resources

Reference for x86-64 instructions: <https://www.felixcloutier.com/x86/>

Ghidra cheat sheet: <https://ghidra-sre.org/CheatSheet.html>

GDB cheat sheet: <https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf>

Overview and Motivations

Languages like Rust, Java, Python and GNU Schemes have memory
guarantees. However, C and C++ are susceptible to memory and memory
corruption bugs (these two languages are the main source of memory bugs
in software)

Chrome has a built-in sandbox so it helps prevent attackers from
reaching the main system even after a successful exploit. However, there
have been instances where an attack group was able to exploit both the
chrome browser and the sandbox.

Uid=1000 (normal user), uid=0 (root)

OSes are also massive codebases, filled with bugs. Many of the CVEs
reported can allow attackers to escalate from a lower privileged user to
root.

Full-stack exploit means an exploit going from a software (like Chrome)
and all the way down to the kernel.

There are many companies that have security researcher roles in
softwares along with firms that just specialize in Vulnerability
Research.

Registers

Types of registers: General purpose, special purpose registers, other
registers (x86-64 has too many registers)

Rax, Rbx, Rcx, Rdx, Rsi, Rdi, r8-r15

Can access 32 (eax, r8d, etc.), 16 (ax, r8w, etc.), 8 (al, r8b, etc.)
bit variants.

For some (rax, rbx, rcx, rdx), you can also access the second least
significant registers.

Stack -- high to low

Heap -- low to high

RFLAGS -- Flags register. Holds the result flags of arithmetic
operations.

RBP -- Frame Pointer Register -- Holds the address of the start of the
frame while stack pointer is usually the end of the frame.

In x86 there are many different modes for addressing registers:

Immediate, Register, Indirect (address stored in register), Indirect
with direct displacement (address in register + offset), indirect based
with scaled-index and direct displacement (scaling factors: 1, 2, 4, 8).

A word is 16 bits (for legacy reasons -- original Intel architecture is
x16), Dword is 32 bits, Qwords is 64 bits

Instructions:

Mov -- mov dest, src

Variants: movzx (move zero extend), movsz (move sign extend)

lea -- Store address of second operand into first operand. Destination
must be general purpose register, source must be a memory address based
on addressing modes

lea dest_reg, src_reg

and, or, xor, not

sar, shr, shl, ror, rol, rcr, rcl -- Bit shifting/ rotating operations

cmp -- set flags bu doing a comparison through subtraction; subtraction
result is discarded

Common Flags:

\- ZF -- if result if the operation is zero

\- CF -- if the unsigned operation had a carry bit

\- OF -- if the signed operation had an overflow

\- SF -- whether the operation yielded a negative result

jmp -- Takes either a signed literal (e.g jmp 0x1 -- jumps to rip + 1),
or absolute registers + deferenced pointers (jmp rax, jmp qword ptr
\[rax + rbx\*8\])

jcc -- Jump if condition is met -- jge, jle, je, jne, js, jns, jl, jz,
jo, jno, jnz, etc. - These implementations rely on flags.

xchg opA, opB -- exchanges contents of first operant with second operant
(can be register register, or register memory)

rep -- repeat until rcx is 0), repe/repne (repeat until rcx is 0 or zf
condition fails)

syscall -- make calls to the kernel

ud2 -- useful in our activity, as it purposely raises an **invalid
opcode exception**

nop -- does nothing. Technically x86 implements this through an alias
(it really is just xchg rax, rax for 64-bit)

Notes:

When register is a sub-register, only that part is written unless the
sub-register is 32 bits, in which the upper 32 bits in zeroed out
(thanks Intel!)

Default decrement/increment size for push and pop will be 8 in x86-64

Intel has many **undocumented **instructions which in the past has led
to vulnerabilities.

Calling convention -- In Linux, the SYSVABI conventions are followed

Function arguments: rdi, rsi, rdx, rcx, r8, r9, then stack in reverse
order

Return value: rax, or dfx:rax pair

16 byte alginment before function calls (not always enforced)

Callee saved: rbx, rsp, rbp, r12-r15

Caller saved: rax, rdi, rsi, rdx, rcx, r8-r11

Function Prologues: push rbp; mov rbp, rsp; sub rsp, X where X is the
size of frame

Epilogues: mov rsp, rbp; pop rbp; ret

or leave, ret

How Java implements hashing function:

![](Pictures/Pictures/1000000100000258000001FA07812A739EDE01B1.png){width="3.8465in"
height="3.2437in"}

C/C++ compiles to assembly, which gets assembled into machine code.
Compilation process is complex!

Do reverse engineers only read assembly from disassemblers? They
generally rely on it, but decompilers results are also very useful
(allow them to quickly get a high-level idea).

Day 1 challenges are all dynamically linked with glibc, so you can
easily find program main from the entry symbol (address of main is the
first argument to binary function \_\_libc_start_main)

However, it's is 100% better practice to do these with only disassembly
using objdump. Use **-m Intel **to get Intel syntax disassembly 9try to
avoid AT&T syntax)

Day 2

Linux binaries are in the format of ELFs (Executable and Linkable
Format), while Windows binaries are in the PE format (Portable
Executable)

Binary divides into different segments, which then subdivides into
section.

![](Pictures/Pictures/10000001000005B9000001BFC67354393458290D.png){width="6.9252in"
height="2.1126in"}

When you compile a binary as static, you are bundling all the library
functions into the binary itself, which yields in faster execution and
decreases a lot of potential dependency issues, but increases file size.
On the other hand, dynamic linking will only include your code in the
binary, where the remaining information is left for the linker to
resolve library calls at runtime. Dynamic linking resolves calls with
the help of the PLT and GOT tables.

Common section names: .text, .data (constant global variables), .bss
(zero-initialized global variables - writable), .plt (code stub
placeholders for library functions that calls the dynamic linker to load
the function), .got (stores the address of resolved libraries)

When executing a dynamic ELF, the linker must be called first, which
goes through and loads the required libraries before jumping to the
binary's entrypoint. For static binaries the executable is called
directly.

Ghidra intro

Normally when you use objdump you get a raw disassembly output of the
binary. However, with programs like Ghidra and IDA they attempt to
analyze the assembly code and translate it into raw C.

Note that Ghidra names analyzed function based on their address added
with a constant of 0x100000.

We can retype function with right-clicking and changing function
signature. We can also change the calling conventions and registers that
the function is using, along with changing info for variables, local and
global (change type, rename). With constants you can also change view,
e.g. change from displaying hex to string or int

Also, if you mess up with an action, Ghidra allows you to do Ctrl+Z.
There is also a graph view! (found in top bar) along with a function
call graph (Windows → Function Call Graph)

Often times, you can parse C header files in Ghidra to import a lot of
different structs at the same time. This helps you to be able to break
down the custom types in a binary. To search strings, do Ctrl+Shift+E or
Search → Strings

Another really important feature of Ghidra is xrefs, which allows you to
cross reference where data/variable/functions are referenced from. For
example, any comparison functions like *memcmp/strcmp *are always of
interest. It also help shows whether the xref is a read/write/call

\- Denoted with R = read, C = call, W = write

To edit the binary itself, right click on an instruction and choose
"Patch instruction". This will allow you to change it to another
instruction. After that you can *export *the program. However, in
general, this is more easily done with hex editors.

Introductory RE advice

*- *Library function calls can give a lot of hints about the binary's
variable types.

\- If you see consistent offsetting into a variable, it's likely part of
a struct.

\- Decompilation isn't always 100% accurate, so always keep the disas in
mind! This is particularly true when the code is very optimized.

\- If you see some weird hex constants, search them up! Chances are it's
something with optimized arithmetic, or part of some well known
algorithms.

For example, compilers are famous for doing this to division and doing
arithmetic with magic constants. Additionally, any crypto functions will
have known constants as well.

Demo

Linux ELF has a canary stored at offset of 0x28 which is checked at the
end of the function

ENDBR64 -- On most processors it's a nop but on newer Intel processors
the instruction as a security check.

Looking up \_c_type_b\_loc() in the glibc library indicates its usage.
For the program it's being used to check for each character in the given
buffer is alphanumeric, and if so, it would shift the character by 13.
=\> From this we can see that the function is performing a Caesar cipher

The last part of the program performs a base64 encoding. We can detect
this by searching up the reference string that the function was using to
replace the original string

Day 3

Note: Generally, Will prefers *static analysis* for reversing (at last
at the start), rather than relying on dynamic analysis with debuggers.
This is because you often don't get the whole picture and start wasting
time. Instead, go with dynamic analysis when you already know some
things about the program and want to confirm or inspect certain
behaviors.

Gef adds a lot of cool features to gdb. Other useful tools for dynamic
analysis on Linux includes strace (to dump syscalls from processes and
show function arguments), ltrace (the equivalent of trace, but for
binary calls).

![](Pictures/Pictures/1000000100000432000000D8478B540DBB8002EF.png){width="6.9252in"
height="1.3925in"}

starti - break on first instruction

vmmap -- similar to show info proc mappings

info br -- info of breakpoints

si -- step one instruction exactly

ni -- step one instruction exactly but goes over subroutine calls

c -- continue binary execution

si, ni, and c takes an optional argument to indicate how many times they
should be executed.

![](Pictures/Pictures/100000010000051D000000E23CFD8D2AEE8281C2.png){width="6.9252in"
height="1.1953in"}

Software breakpoints work using *ptrace syscall, *which basically
replaces the instruction you want to break on with something like 0xcc
(int3) to cause an exception which the exception handler of the debugger
will handle.

info frame -- shows important information about current stack frame,
including where the return address and frame pointers are stored.

info threads -- provides information about threads

bt -- Backtrace. Shows all function calls that have led to the current
point =\> Really useful for crashes!

registers -- show many general purpose registers, but won't do most
segment registers (gdb usually don't have access to them)

all registers -- show all registers

You can also make function calls in gdb using **call expr** like 'call
puts("hello")' along with *setting registers values *like set \$sp += 4

Watchpoints are extensions to breakpoints, which takes an expr as an
argument, so you can tell awatch to look for read/write, and tell rwatch
to look for read operations. Breakpoints themselves can also take in a
condition (so it only breaks when a condition is true).

search "/bin/sh" -- searches for the string in the program's memory.

search-pattern 0x1337beef -- search for a hex constant or pointer in
memory.

There are other commands to search for particular sequence of bytes with
the find command.

set follow-fork-mode child/parent -- Tell gdb which process to follow
when process forks.

edit-flags -- gef command that provides an easy way to edit the RFLAGS

Anti-reversing strategies

-   Against dynamic analysis and debugging: are not very common in
    software, but rather in software license code and video games. Most
    big programs won't have a lot of obfuscation and anti-debug
    features.

\- Time the process, and if one function takes too long, assume it's
being debugged and do something about it.

\- Checking process list (ban having IDA/GHIDRA open)

\- Checksum verification of binary against patching

\- Try to prevent dumping, or make dumps not get all the information

\- Some tricks purposefully break debuggers based on known debugger
behavior or bugs (for example, changing format from big to little endian
against normal architecture practice).

However, at the end of the day, if one does static analysis and knows
what tricks you are doing, they can always beat it. For example, loading
custom drivers into the kernel.

Also, many malwares also use anti-reversing techniques to prevent people
from reversing it.

-   Against static analysis

-Self-unpacking binaries, self-decrypting binaries, metamorphic code

Though this isn't that effective at the end of the day.

\- Stripped and overly optimized code (using lots of indirect calls) =
makes it a lot harder for the reverser

Note a lot of the times binaries are not stripped in the real world,
even when compiling C code in release mode for example. By default C
don't add debug symbols but they would still have function symbols.

To strip a binary, do -- *strip binary_name*

\- Code obfuscation -- obfuscate code flow, obfuscate assembly
\[constant expansion (do tons of extra arithmetic) + duplication,
deadcode (code that has no effect on program), instruction expansion
(take one instruction and turn it into many, like subleq \]

However, these days decompiler algorithms are getting better, so they
can obfuscate more by just analysis.

\- Virtualization -- most effective method. You take your real program
and translate it into a custom language, and the binary runs a VM
interpreter to interpret the bytecode. This requires an extreme amount
of effort for a reverse engineer to de-virtualize. VMProtect and Themida
is very good at this. You can also stack different VMs on top of each
other.

VMs also tends to bring in randomness (changing size of structs in each
program run) and aforementioned obfuscation methods.

However, this really greatly impact the performance of the program, so
it is only saved for the most important parts of the program.

\- Anti-VM -- a strategy common in malware and gaming anti-cheat, and it
prevents you from running software in Virtual Machine. For example,
there are certain x86_64 instructions that behave differently under
virtualization, and so you can detect whether or not you are running a
VM.

That said, these strategies are still mostly bypassable, whether from
running hardened VM configurations or find some other way in the program
to bypass those checks.

Intermediate bytecode compiled languages (C#, Java, Python bytecode
etc.) are usually much easier to reverse, since there is a lot of
intermediate metadata that is retained so decompilers can create much
more accurate and better looking code.

![](Pictures/Pictures/10000001000004BA00000173EEC6D08F4410F8FB.png){width="6.9252in"
height="2.1228in"}
